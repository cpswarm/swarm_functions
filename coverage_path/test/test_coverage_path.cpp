#include <gtest/gtest.h>
#include <ros/ros.h>
#include <actionlib/client/simple_action_client.h>
#include <nav_msgs/GetPlan.h>
#include <geometry_msgs/PoseStamped.h>
#include <cpswarm_msgs/GetWaypoint.h>
#include <cpswarm_msgs/PathGenerationAction.h>
#include <cpswarm_msgs/StateEvent.h>
#include <cpswarm_msgs/ArrayOfStates.h>

using namespace std;
using namespace ros;

/**
 * @brief Test the coverage path action server.
 */
TEST (NodeTestCoveragePath, testActionServer)
{
    // create action client
    actionlib::SimpleActionClient<cpswarm_msgs::PathGenerationAction> path_client("coverage_path/generate", true); // new thread
    ASSERT_TRUE(path_client.waitForServer(Duration(5.0))); // failure, if server does not respond within 5 seconds

    // call action server
    cpswarm_msgs::PathGenerationGoal goal;
    goal.start.x = -10;
    goal.start.y = -10;
    path_client.sendGoal(goal);
    ASSERT_TRUE(path_client.waitForResult(Duration(5.0))); // failure, if result is not ready within 5 seconds

    // test result
    vector<geometry_msgs::PoseStamped> path = path_client.getResult()->path.poses;
    ASSERT_EQ(path.size(), 81);
    // start point
    geometry_msgs::Point pos = goal.start;
    pos.x += 0.25;
    pos.y += 0.25;
    EXPECT_FLOAT_EQ(path[0].pose.position.x, pos.x);
    EXPECT_FLOAT_EQ(path[0].pose.position.y, pos.y);

}

/**
 * @brief Test the coverage path waypoint service (uses path generated by first test).
 */
TEST (NodeTestCoveragePath, testService)
{
    NodeHandle nh;

    // create waypoint service client
    ServiceClient get_wp_client = nh.serviceClient<cpswarm_msgs::GetWaypoint>("coverage_path/waypoint");
    ASSERT_TRUE(get_wp_client.waitForExistence(Duration(5.0)));

    // test all waypoints
    cpswarm_msgs::GetWaypoint gwp;

    // start point
    gwp.request.position.x = -10;
    gwp.request.position.y = -10;
    gwp.request.tolerance = 0.1;
    ASSERT_TRUE(get_wp_client.call(gwp));
    ASSERT_TRUE(gwp.response.valid);
    gwp.request.position.x += 0.25;
    gwp.request.position.y += 0.25;
    EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
    EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);

    // meander to the right
    for (int i=1; i<77; i+=4) {
        gwp.request.position.y = 9.75;
        ASSERT_TRUE(get_wp_client.call(gwp));
        ASSERT_TRUE(gwp.response.valid);
        EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
        EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
        EXPECT_TRUE(gwp.response.valid);
        gwp.request.position.x += 0.5;
        ASSERT_TRUE(get_wp_client.call(gwp));
        ASSERT_TRUE(gwp.response.valid);
        EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
        EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
        gwp.request.position.y = -9.25;
        ASSERT_TRUE(get_wp_client.call(gwp));
        ASSERT_TRUE(gwp.response.valid);
        EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
        EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
        gwp.request.position.x += 0.5;
        ASSERT_TRUE(get_wp_client.call(gwp));
        ASSERT_TRUE(gwp.response.valid);
        EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
        EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
    }
    // return to start
    gwp.request.position.y = 9.75;
    ASSERT_TRUE(get_wp_client.call(gwp));
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
    EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
    gwp.request.position.x += 0.5;
    ASSERT_TRUE(get_wp_client.call(gwp));
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
    EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
    gwp.request.position.y = -9.75;
    ASSERT_TRUE(get_wp_client.call(gwp));
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
    EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
    gwp.request.position.x = -9.75;
    ASSERT_TRUE(get_wp_client.call(gwp));
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, gwp.request.position.x);
    EXPECT_FLOAT_EQ(gwp.response.point.y, gwp.request.position.y);
    ASSERT_TRUE(get_wp_client.call(gwp));
    ASSERT_FALSE(gwp.response.valid);
}

/**
 * @brief Test the coverage path regeneration on swarm changes.
 */
TEST (NodeTestCoveragePath, testSwarm)
{
    NodeHandle nh;

    // create action client
    actionlib::SimpleActionClient<cpswarm_msgs::PathGenerationAction> path_client("coverage_path/generate", true); // new thread
    ASSERT_TRUE(path_client.waitForServer(Duration(5.0))); // failure, if server does not respond within 5 seconds

    // call action server to create new path
    cpswarm_msgs::PathGenerationGoal goal;
    goal.start.x = 10;
    goal.start.y = -10;
    path_client.sendGoal(goal);
    ASSERT_TRUE(path_client.waitForResult(Duration(5.0))); // failure, if result is not ready within 5 seconds
    // test result
    vector<geometry_msgs::PoseStamped> path = path_client.getResult()->path.poses;
    ASSERT_EQ(path.size(), 81);
    // start point
    geometry_msgs::Point pos = goal.start;
    pos.x -= 0.25;
    pos.y += 0.25;
    EXPECT_FLOAT_EQ(path[0].pose.position.x, pos.x);
    EXPECT_FLOAT_EQ(path[0].pose.position.y, pos.y);

    // create waypoint service client
    ServiceClient get_wp_client = nh.serviceClient<cpswarm_msgs::GetWaypoint>("coverage_path/waypoint");
    ASSERT_TRUE(get_wp_client.waitForExistence(Duration(5.0)));

    // swarm member publisher
    Publisher swarm_publisher = nh.advertise<cpswarm_msgs::ArrayOfStates>("swarm_state", 1);

    // test start point
    cpswarm_msgs::GetWaypoint gwp;
    gwp.request.position.x = 10;
    gwp.request.position.y = -10;
    gwp.request.tolerance = 0.1;
    ASSERT_TRUE(get_wp_client.call(gwp)); // generates a new path with given start
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, 9.75);
    EXPECT_FLOAT_EQ(gwp.response.point.y, -9.75);

    // test start point
    gwp.request.position.x = 5;
    gwp.request.position.y = 5;
    gwp.request.tolerance = 0.1;
    ASSERT_TRUE(get_wp_client.call(gwp)); // uses existing path, same start point
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, 9.75);
    EXPECT_FLOAT_EQ(gwp.response.point.y, -9.75);

    // change swarm
    Rate rate(1);
    for (int i=0; i<10; ++i) {
        rate.sleep();
        if(swarm_publisher.getNumSubscribers() > 0)
            break;
    }
    ASSERT_EQ(swarm_publisher.getNumSubscribers(), 1);
    cpswarm_msgs::ArrayOfStates swarm_state_msg;
    cpswarm_msgs::StateEvent state_event;
    state_event.header.stamp = Time::now();
    state_event.swarmio.node = "New CPS";
    state_event.state = "valid";
    swarm_state_msg.states.push_back(state_event);
    swarm_publisher.publish(swarm_state_msg);
    spinOnce();

    // test start point
    gwp.request.position.x = 5;
    gwp.request.position.y = 5;
    gwp.request.tolerance = 0.1;
    ASSERT_TRUE(get_wp_client.call(gwp)); // generate new path, new start point
    ASSERT_TRUE(gwp.response.valid);
    EXPECT_FLOAT_EQ(gwp.response.point.x, 5.25);
    EXPECT_FLOAT_EQ(gwp.response.point.y, 5.25);
}

/**
 * @brief Main function that runs all tests that were declared with TEST().
 */
int main(int argc, char **argv){
    testing::InitGoogleTest(&argc, argv);
    init(argc, argv, "test_area");
    return RUN_ALL_TESTS();
}
